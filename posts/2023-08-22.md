---
title: "《深入解析CSS》（上）"
subtitle: "基础回顾和布局介绍"
date: "2023-08-22"
image: "https://cdn.pixabay.com/photo/2023/11/08/05/46/winter-8373941_1280.jpg"
category: "笔记"
---

<div  align="center">    
<img src="/images/css-in-depth.jpg" width = "300" height = "200" alt="图片名称" align=center />
</div>


> 做官网工作的时候有很多需要适配移动端的改样式工作，深感自身的CSS能力不足，于是想着找一本书系统地学一下，在微信读书上发现了这一本**图灵**出版的，品下来确实受益匪浅

## 1.1 层叠

  如果选择器的ID数量更多，则它会胜出（即它更明确）。❑ 如果ID数量一致，那么拥有最多类的选择器胜出。❑ 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。

 伪类选择器（如：hover）和属性选择器（如[type="input"]）与一个类选择器的优先级相同。通用选择器（＊）和组合器（>、+、~）对优先级没有影响。

 通过这些例子可以发现，优先级容易发展为一种“军备竞赛”。在大型项目中这一点尤为突出。通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。

## 2.2 em和rem

 在CSS里，答案通常是“看情况”。rem只是你工具包中的一种工具。掌握CSS很重要的一点是学会在适当的场景使用适当的工具。我一般会用rem设置字号，用px设置边框，用em设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）

 拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。

## 2.3 停止像素思维

 通过给页面根元素设置不同字号，我们响应式地重新定义了整个网页的em和rem。也就是说，即使不直接修改面板的样式，它也是响应式的。在小屏上，比如智能手机上，字体会较小（12px），内边距和圆角也相应较小。在大于800px和1200px的大屏上，组件会相应地分别放大到14px和16px的字号。缩放浏览器窗口可以看到这些变化。如果你足够严格，整个网页的样式都像这样使用相对单位定义，那么网页就会根据视口大小整体缩放。这是响应式策略中很重要的一部分。靠近样式表顶部的两个媒体查询可以极大减少后续CSS代码中媒体查询的数量。如果用像素的话，就没有这么容易。同样，如果老板或者客户觉得网页的字体太大或者太小，只需要改一行代码就能改变整体的字号，进而不费吹灰之力影响整个网页。

## 2.4 视口的相对单位

 现在打开网页，慢慢缩放浏览器，字体会平滑地缩放。0.5em保证了最小字号，1vw则确保了字体会随着视口缩放。这段代码保证基础字号从iPhone 6里的11.75px一直过渡到1200px的浏览器窗口里的20px。可以按照自己的喜好调整这个值。

## 2.6 自定义属性（即CSS变量）

 调用函数var()就能使用该变量。

 在不支持自定义属性的浏览器上，任何使用var()的声明都会被忽略。请尽量为这些浏览器提供回退方案。

## 2.7 总结

 拥抱相对单位，让网页的结构决定样式的含义。

 建议用rem设置字号，但是有选择地用em实现网页组件的简单缩放。

 不用媒体查询也能让整个网页响应式缩放。

 使用无单位的值设置行高。

 请开始熟悉CSS的一个新特性：自定义属性。

## 3.1 元素宽度的问题

 26%是一个魔术数值（magic number）。它不是一个理想的值，而是通过改样式试出来的值。

 box-sizing的默认值为content-box，这意味任何指定的宽或高都只会设置内容盒子的大小。将box-sizing设置为border-box后，height和width属性会设置内容、内边距以及边框的大小总和，这刚好符合示例的要求。

 如果要开发一个新的网站，我建议将代码清单3-6加到CSS中，因为从长远来看，这会给你省去很多麻烦。

 这种方式不仅能够使用em指定间距，而且能让代码意图更明显。之后再看代码，从代码清单3-7中可能看不出为什么使用29%，但是代码清单3-8中的30% -1.5em则能提供线索，知道它是基于30%算出来的。

## 3.2 元素高度的问题

 通常情况下，我倾向于使用auto而不是scroll，因为在大多数情况下，我不希望滚动条一直出现

 如果将主列和侧边栏的高度对齐（如图3-10所示），看起来就会更精致。任意一列的内容增加，两列的高度都会增加，同时保持底部对齐。

 正的外边距会将容器的边缘往里推，而负的外边距则会将边缘往外拉

 Flexbox不需要一个额外的div包裹元素，它默认会产生等高的元素。此外也不需要使用负外边距。

 给容器设置display: flex，它就变成了一个弹性容器（flex container），子元素默认等高。

 除非别无选择，否则不要明确设置元素的高度。先寻找一个替代方案。设置高度一定会导致更复杂的情况。

 vertical-align声明只会影响行内元素或者table-cell元素。对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。

## 3.4 外边距折叠

 折叠外边距的大小等于相邻外边距中的最大值。

 只有上下外边距会产生折叠，左右外边距不会折叠

 折叠外边距就像“个人空间”。如果在公交车站站着两个人，他们每个人都认为较为舒适的个人空间应为3英尺[插图]，那么他们就会乐意间隔3英尺，而不必间隔6英尺才让双方满意。

 这也就是说可以给任何元素加上外边距，而不必担心它们前后的元素是什么。

## 3.6 总结

 ❑ 总是全局设置border-box，以便得到预期的元素大小。❑ 避免明确设置元素的高度，以免出现溢出问题。❑ 使用现代的布局技术，比如display: table或者Flexbox实现列等高或者垂直居中内容。❑ 如果外边距的行为很奇怪，就采取措施防止外边距折叠。❑ 使用猫头鹰选择器全局设置堆叠元素之间的外边距。

## 4.1 浮动的设计初衷

 这里使用了max-width而不是width，因此如果视口宽度小于1080px的话，内层容器就能缩小到1080px以下。换句话说，在小视口上，内层容器会填满屏幕，在大视口上，它会扩展到1080px。这种方式能有效避免在小屏幕上出现水平滚动条。

## 4.2 容器折叠和清除浮动

 要用display: table来清除浮动，同时利用隐式创建单元格来包含外边距

## 4.4 媒体对象和BFC

 为了实现右边这种布局，需要为正文建立一个块级格式化上下文（block formatting context,BFC）。BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。

 简而言之，BFC里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加clear属性，它只会清除自身所在BFC内的浮动。如果强制给一个元素生成一个新的BFC，它不会跟其他BFC重叠。

 给元素添加以下的任意属性值都会创建BFC。❑ float: left或right，不为none即可。❑ overflow:hidden、auto或scroll，不为visible即可。❑ display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器（block container）。❑ position:absolute或position: fixed。

 使用overflow: auto通常是创建BFC最简单的一种方式

## 4.5 网格系统

 ＊=比较符可以匹配任意包含指定字符串的值，比如本例中可以匹配在类属性的任意位置出现column-的元素。

## 4.6 总结

 浮动的设计初衷是让文字围绕一个元素排列，但有时这种效果并不是我们想要的。❑ 使用清除浮动来包含浮动元素。❑ BFC有3个好处：包含浮动元素，防止外边距折叠，防止文档流围绕浮动元素排列。❑ 使用双容器模式让页面内容居中。❑ 使用媒体对象模式将描述文字定位到图片旁边。❑ 使用网格系统实现更丰富的网页布局。

## 5.2 弹性子元素的大小

 flex-basis定义了元素大小的基准值，即一个初始的“主尺寸”。

 多出来的留白（或剩余宽度）会按照flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow的值为非负整数。

 flex-shrink属性与flex-grow遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出（如图5-12所示

 每个子元素的flex-shrink值代表了它是否应该收缩以防止溢出。如果某个子元素为flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照flex-shrink值的比例，值越大的元素收缩得越多。

## 5.4 对齐、间距等细节

 值space-between将第一个弹性子元素放在主轴开始的地方，最后一个子元素放在主轴结束的地方，剩下的子元素间隔均匀地放在这两者之间的区域。值space-around类似，只不过给第一个子元素的前面和最后一个子元素的后面也加上了相同的间距。间距是在元素的外边距之后进行计算的，而且flex-grow的值要考虑进来。也就是说，如果任意子元素的flex-grow的值不为0，或者任意子元素在主轴方向的外边距值为auto, justify-content就失效了。

 justify-content控制子元素在主轴方向的对齐方式，align-items则控制子元素在副轴方向的对齐方式。

 两个弹性子元素的属性：align-self和order。

 该属性控制弹性子元素沿着容器副轴方向的对齐方式。它跟弹性容器的align-items属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式

## 5.5 值得注意的地方

 Flexbox的实现是CSS的一大进步。一旦你熟悉了它，你可能想要在页面的每个地方都开始使用，不过你应该依靠正常的文档流，只在必要的时候才使用Flexbox。这么说并不是让你不用它，而是希望你不要拿着锤子满世界找钉子。

 他给出的一个建议是对整页布局的时候使用网格布局

## 5.6 总结

 使用align-items和align-self让一个弹性子元素在弹性容器中垂直居中。

## 6.2 网格剖析

 有一点值得注意的是，使用网格并不会让Flexbox失去用武之地。在这个网页的布局里面Flexbox仍然是重要部分。我会把应当使用Flexbox的地方指出来。

 用repeat()符号还可以定义不同的重复模式，比如repeat(3, 2fr 1fr)会重复三遍这个模式，从而定义六个网格轨道，重复的结果是2fr 1fr 2fr 1fr 2fr 1fr。

 学了网格之后，开发人员经常会问到Flexbox，特别是会问这两种布局方式是否互斥。当然不会，它们是互补的。二者几乎是一起开发出来的，虽然它们的功能有一些重叠的地方，但是它们各自擅长的场景不一样。在一个设计场景里，要根据特定的需求来做出选择。

  Flexbox本质上是一维的，而网格是二维的

 Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的

 因为Flexbox是一维的，所以它很适合用在相似的元素组成的行（或列）上。它支持用flex-wrap换行，但是没法让上一行元素跟下一行元素对齐。相反，网格是二维的，旨在解决一个轨道的元素跟另一个轨道的元素对齐的问题。

## 6.3 替代语法

 当你构建一个网格时，选择一种舒适的语法即可。网格布局共设计了三种语法：编号的网格线、命名的网格线、命名的网格区域。

## 6.4 显式和隐式网格

 使用grid-template-＊属性定义网格轨道时，创建的是显式网格（explicit grid），但是有些网格元素仍然可以放在显式轨道外面，此时会自动创建隐式轨道以扩展网格，从而包含这些元素。

 有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。（如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。）通过指定minmax(200px, 1fr)，浏览器确保了所有的轨道至少宽200px。

 repeat()函数里的auto-fill关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（minmax()值）的限制产生冲突。

 auto-fill和minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px

 还可以额外加一个关键字dense（比如，grid-auto-flow: column dense）。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字，小元素就会“回填”大元素造成的空白区域。

 网格有一个限制是要求用特定的DOM结构，也就是说，所有的网格元素必须是网格容器的直接子节点。因此，不能将深层嵌套的元素在网格上对齐

 可以给网格元素加上display: grid，在外层网格里创建一个内部网格，但是内部网格的元素不一定会跟外层网格的轨道对齐。一个网格里的子元素的大小也不能影响到另一个网格的网格轨道大小。

 将来可以使用子网格（subgrid）来解决这个问题。通过给一个网格元素设置display:subgrid，将其变成自己的内部网格容器，网格轨道跟外部网格的轨道对齐。不幸的是，这个特性还没有被任何浏览器实现，因此它被推迟到网格规范的Level2版本中。

 ❑ cover：扩展图片，让它填满盒子（导致图片一部分被裁剪）。❑ contain：缩放图片，让它完整地填充盒子（导致盒子里出现空白）。

## 6.6 对齐

 还有三个对齐属性：align-content、align-items、align-self。这些属性控制网格元素在垂直方向上的位置。我是这样记的：就像表格布局里的vertical-align属性。

## 6.7 总结

 网格特别适合做网页整体布局

 网格可以与Flexbox配合实现完整的布局系统。

 可以根据自己的喜好和特定场景，随意使用不同的语法（编号的网格线、命名的网格线、命名的网格区域）。

 可以用auto-fill / auto-fit以及隐式网格，对大量或者数量未知的网格元素进行布局。

### 继续阅读：[理解和精通布局](./2023-09-23)