---
title: "《深入解析CSS》（下）"
subtitle: "理解和精通布局"
date: "2023-09-22"
---

### [基础回顾](./2023-09-22)
 
## 7.1 固定定位

 因为固定元素从文档流中移除了，所以它不再影响页面其他元素的位置。别的元素会跟随正常文档流，就像固定元素不存在一样。也就是说它们通常会在固定元素下面排列，视觉上被遮挡。这对于模态框来说没问题，因为我们希望模态框出现在最前面的中间位置，直到用户关闭它。而对于其他固定元素，比如侧边导航栏，就需要注意不要让其他内容出现在它下面。通常给其他内容加一个外边距就能解决该问题。比如，将所有内容放在容器里，容器设置right-margin:20%。外边距会流到固定元素下面，内容就不会跟导航栏重叠。

## 7.2 绝对定位

 你可能首先想到将按钮里的文字close换成x，但是这会导致可访问性的问题：辅助的屏幕阅读器会读按钮里的文字。因此要给这个按钮一些有意义的提示。在使用CSS之前，HTML本身必须有意义。相反，你可以用CSS隐藏close，并显示x。总共需要两步。首先将按钮的文字挤到外面，并隐藏溢出内容。然后将按钮的：:after伪元素的content属性设置为x，并让伪元素绝对定位到按钮中间

## 7.3 相对定位

 元素四周的边都变成了三角形。顶部的边箭头指向下边，右边的边指向左边，以此类推。基于这个现象，可以用一条边作为三角形，然后将剩下的边设置为透明。

 另外你也可以用一个图片或者背景图来实现箭头，但是用短短几行CSS代码就可以为用户免去不必要的网络请求。加上这个小小的箭头，能给网站或应用程序增色不少。这项技术还可以用来构建其他复杂形状，比如梯形、六边形和星形。查看用CSS构建的各种形状，可以访问css-tricks网站上的文章The Shapes of CSS。

## 7.4 层叠上下文和z-index

 通常情况下，模态框要放在网页内容的最后，</body>关闭标签之前。大多数构建模态框的JavaScript库会自动这样做。因为模态框使用固定定位，所以不必关心它的标记出现在哪里，它会一直定位到屏幕中间。

 改变固定定位元素的标记位置不会产生不好的影响，但是对相对定位或绝对定位的元素来说，通常无法用改变标记位置的方法解决层叠问题。相对定位依赖于文档流，绝对定位元素依赖于它的定位祖先节点。这时候需要用z-index属性来控制它们的层叠行为。

 z-index的行为很好理解，但是使用它时要注意两个小陷阱。第一，z-index只在定位元素上生效，不能用它控制静态元素。第二，给一个定位元素加上z-index可以创建层叠上下文。

 层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠。

 给一个定位元素加上z-index是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于1的opacity属性，还有transform、filter属性。由于这些属性主要会影响元素及其子元素渲染的方式，因此一起绘制父子元素。文档根节点也会给整个页面创建一个顶级的层叠上下文。

 所有层叠上下文内的元素会按照以下顺序，从后到前叠放：

 有些开发人员会忍不住给页面的大量元素使用定位。一定要克制这种冲动。定位用得越多，网页就越复杂，也就越难调试。如果你定位了大量元素，就回头评估一下现在的情况，尤其是当你发现很难调试出自己想要的布局时，一定要反思。如果可以用别的方法实现某个布局，应该优先用那些方法。

 如果能够依靠文档流，而不是靠明确指定定位的方式实现布局，那么浏览器会帮我们处理好很多边缘情况。记住，定位会将元素拉出文档流。一般来说，只有在需要将元素叠放到别的元素之前时，才应该用定位。

## 7.6 总结

 ❑ 模态框使用固定定位。❑ 下拉菜单、工具提示及其他动态交互使用绝对定位。❑ 实现这些功能时还要考虑可访问性。❑ 关于z-index有两个地方要注意：它只对定位元素有效；它会创建一个层叠上下文。❑ 在一个页面创建多个层叠上下文时一定要当心潜在的陷阱。❑ 使用粘性定位时注意浏览器的兼容性。

## 第8章 响应式设计

 响应式设计的三大原则如下。(1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。(2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。(3) 流式布局。这种方式允许容器根据视口宽度缩放尺寸。

## 8.1 移动优先

 响应式设计的第一原则就是移动优先（mobile first），顾名思义就是构建桌面版之前要先构建移动端布局。这样才能确保两个版本都生效。开发移动版网页有很多限制：屏幕空间受限、网络更慢。用户跟网页交互的方式也不一样：可以打字，但是用着很别扭，不能将鼠标移动到元素上触发效果等。如果一开始就设计一个包含全部交互的网站，然后再根据移动设备的限制来制约网站的功能，那么一般会以失败告终。而移动优先的方式则会让你设计网站的时候就一直想着这些限制。一旦移动版的体验做好了（或者设计好了），就可以用“渐进增强”（progressive enhancement）的方式为大屏用户增加体验。

 做响应式设计时，一定要确保HTML包含了各种屏幕尺寸所需的全部内容。你可以对每个屏幕尺寸应用不同的CSS，但是它们必须共享同一份HTML。

 断点——一个特殊的临界值。屏幕尺寸达到这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。

 当点击汉堡包图标的时候，会打开下拉菜单，可以看到菜单的文字出现在网页内容前面。再次点击汉堡包图标就会关闭菜单。这种方式下，CSS会负责显示和隐藏指定元素，JavaScript只需要负责改变一个类。

## 8.2 媒体查询

 大多数情况下，整个样式表里的媒体查询只会复用少数几个断点。

 还可以进一步将两个条件用and关键字联合起来组成一个媒体查询，如下代码所示。[插图]这种联合媒体查询只在设备同时满足这两个条件时才生效。如果设备只需要满足多个条件之一，可以用逗号分隔，如下代码所示。[插图]这句媒体查询匹配小于等于20em的视口，以及大于等于35em的视口。

 当你想在高分辨率的屏幕上提供更高清的图片或者图标时，可以用这种方法。这样低分辨率的屏幕就不会浪费带宽去加载大图，因为在这些屏幕上看不出区别。本章稍后会详细介绍响应式图片。

 使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景图（节省墨水），隐藏不必要的导航栏。当用户打印网页时，他们通常只想打印主体内容。

 最优先的是移动端样式，因为它们不在媒体查询里，所以这些样式对所有断点都有效。然后是针对中等屏幕的媒体查询，其中的规则基于移动端样式构建并且会覆盖移动端样式。最后是针对大屏幕的媒体查询，在这里添加网页最后的布局。

 有的设计可能只需要一个断点，有的设计可能需要多个断点。对网页上有很多元素来讲，无须给每个断点都添加样式，因为在小屏幕或者中等屏幕的断点下添加的样式规则在大屏幕的断点下也完全有效。

 有时候移动端的样式可能很复杂，在较大的断点里面需要花费较大篇幅去覆盖样式。此时需要将这些样式放在max-width媒体查询中，这样就只对较小的断点生效，但是用太多的max-width媒体查询也很有可能是没有遵循移动优先原则所致。max-width是用来排除某些规则的方式，而不是一个常规手段。

 接下来给中等屏幕断点添加样式。在较大的屏幕上，可用空间较多，布局可以较宽松一些。在代码清单8-9中，给头部和主元素添加更大的内边距，然后单独给主图加大内边距，使它更加明显，同时给页面增加了更多的视觉趣味。导航菜单不必隐藏了，要隐藏汉堡包图标，并让菜单项一直显示（参见代码清单8-10）。最终可以将主内容变成三列布局（参见代码清单8-11），页面将如图8-8所示。

 最后一步是要为中等屏幕断点引入多列布局。和前面几章构建多列布局的方式一样，只需要将这些样式封装在一个媒体查询里，这样就不会影响到小于这个断点的屏幕设备。写标记的时候，给想要加上三列布局的地方加上row和column类。

 你可能会好奇为什么在代码清单8-7中要将断点设置为35em，因为在这个宽度时，三列布局就开始显得拥挤了。

 Web设计师Brad Frost列举了一系列响应模式，可以访问 'https://bradfrost.github.io/this-is-responsive/patterns.html' 查看。响应式设计中的列非常灵活多变，比如一宽一窄的列、等宽的列、两列、三列。最终，这些列的布局都会使用类似于本章的方式实现，可能会组合多个列或者更改列宽。

 有时候，甚至不需要媒体查询，自然地折行就能实现响应式的列。可以通过在Flexbox布局中使用flex-wrap: wrap并设置合适的flex-basis来实现。还可以在网格布局中使用auto-fit或者auto-fill的网格列，在折行之前就可以决定一行放几个元素。用inline-block的元素也行，只不过它们无法扩展到填满容器。

 有时候会忍不住想要根据设备选择断点。这个iPhone 7宽多少像素，那个平板设备宽多少像素，等等。不要总想着设备。市面上有成百上千中设备和屏幕分辨率，无法逐一测试。相反，应该选择适合设计的断点，这样不管在什么设备上，都能有很好的表现。

 媒体查询基于视口大小实现响应式设计，但是开发人员和浏览器厂商已经花了好几年时间来寻找更好的解决办法。很多开发人员希望得到的特性是容器查询（container queries），起初叫作元素查询（element queries）。这种查询不是响应视口，而是响应一个元素的容器的大小

## 8.3 流式布局

 要习惯将容器宽度设置为百分比，而不是任何固定的值。

 如果可以的话，建议在移动设备上用别的方式组织数据。比如将每一行数据单独用一块区域展示，让每块区域顺序叠放，或者用更适合小屏的可视化图形或者图表展示。

## 8.4 响应式图片

 响应式图片的最佳实践是为一个图片创建不同分辨率的副本。如果用媒体查询能够知道屏幕的大小，就不必发送过大的图片，不然浏览器为了适配图片也会将其缩小。

 在不同屏幕的浏览器上加载这样的网页，根本看不出有什么区别。这就是关键所在。在小断点下，屏幕尺寸不够宽，反正显示不了完整分辨率的图，但是能节省几百KB的流量。在图片较多的网页上，累计节省的流量就能够显著提升网页加载速度

 这个属性是HTML的一个较新的特性。它可以为一个<img>标签指定不同的图片URL，并指定相应的分辨率。浏览器会根据自身需要决定加载哪一个图片

 图片作为流式布局的一部分，请始终确保它不会超过容器的宽度。为了避免这种情况发生，一劳永逸的办法是在样式表加入规则img {max-width: 100%; 

 网页响应式设计的结构实现方式千变万化。最终这些方式都会归纳为三大原则：移动优先、媒体查询、流式布局。

## 8.5 总结

 ❑ 优先实现移动端设计。❑ 使用媒体查询，按照视口从小到大的顺序渐进增强网页。❑ 使用流式布局适应任意浏览器尺寸。❑ 使用响应式图片适应移动设备的带宽限制。❑ 不要忘记给视口添加meta标签。

## 9.2 一个简单的模块

 常用的写法是使用两个连字符来表示修饰符，比如message--error。

 双连字符的写法很容易区分哪部分是模块名称，哪部分是修饰符

 我们应该避免使用基于通用标签类型的匹配，比如div和span。类似于．page-header >span的选择器太宽泛了。最初建立模块的时候，可能只是用span标签做一件事，但谁也说不准以后会不会出于其他目的再添加第二个span。后面再为span追加类名就比较麻烦了，因为我们需要在HTML标记中找到所有用到模块的地方，全部改一遍。

## 9.3 把模块组合成更大的结构

 关于类的第一条规则是类应该短小，第二条规则是还要更短小

 当模块想要完成不只一件事的时候，我们应该考虑把它拆分成更小的模块

 当我们需要使用并（或者和）来描述模块职责的时候，思考一下是不是在描述两种（甚至更多的）职责。有可能不是，我的经验也不是金科玉律。但如果是的话，我们就需要为每个职责分别定义模块。这是模块封装的一个非常重要的原则，我们把它叫作单一职责原则（Single Responsibility Principle）。尽可能把多种功能分散到不同的模块中，这样每个模块就可以保持精炼、聚焦，并且容易理解。

 状态类的代码要和模块的其他代码放在一起。使用JavaScript动态更改模块表现的时候，要使用状态类去触发改变。

 模块的命名应该有意义，无论使用场景是什么。同时也要避免使用简单地描述视觉效果的名称。把这个模块叫作“带图片的灰盒子”看上去比较通用一些，但是如果之后要改成浅蓝色背景呢？或者重新设计网站呢？这样的名称就不能用了，你还得重新命名，再替换掉HTML里所有用到它的地方。我们应该换一种思路，思考模块代表什么含义。这一般并不容易。“媒体模块”这个名称就很恰当，它代表了一种图文混排的版式。它给人以强烈的印象，并没有将模块局限于任何特定用法或者视觉实现。

 为模块的变体类命名的时候，应该遵守同样的原则。例如，如果已经有按钮模块了，就不应该使用button--red和button--blue命名红色和蓝色变体子类。网站设计在将来有可能会改变，你不知道这些按钮的颜色会不会也跟着变化。应该使用一些更有意义的名称，比如button--danger和button--success。使用大或小这样具有相对意义的词语来命名修饰符不是最佳方式，但也可以接受。没人说过网站重构的时候不能更改button--large的尺寸，只要它还是比标准按钮大一些就可以。一定要牢记，不要使用像button--20px这样特别精确的修饰符。

## 9.4 工具类

 有时候，我们需要用一个类来对元素做一件简单明确的事，比如让文字居中、让元素左浮动，或者清除浮动。这样的类被称为工具类（utility class）。

 从某种意义上讲，工具类有点像小号的模块。工具类应该专注于某种功能，一般只声明一次。我通常把这些工具类放在样式表的底部，模块代码的下面。

 这里用到了两次！important。工具类是唯一应该使用important注释的地方。事实上，工具类应该优先使用它。这样的话，不管在哪里用到工具类，都可以生效。我敢肯定，任何时候为元素添加text-center类，都是想让文本居中，不想让其他样式覆盖它。用了important注释就可以确保这一点。

## 9.6 总结

 ❑ 把CSS拆解成可复用的模块。❑ 不要书写可能影响其他模块或者改变其他模块外观的样式。❑ 使用变体类，提供同一模块的不同版本。❑ 把较大的结构拆解成较小的模块，然后把多个模块组合在一起构建页面。❑ 在样式表中，把所有用于同一个模块的样式放在一起。❑ 使用一种命名约定，比如双连字符和双下划线，以便一眼就可以看清楚模块的结构。

## 10.1 KSS简介

 KSS会按照特定的方式在样式表中搜寻注释。注释中包含了标题（通常是模块名称）、描述信息、示例HTML代码和用来表示该模块在目录中位置的Styleguide注释。这几个部分之间通过空白行彼此间隔，便于KSS区分它们。严格来讲，只有最后的Styleguide注释是KSS必需的，但是通常我们也应该好好编写其余部分。

## 10.2 改变编写CSS的方式

 模式库对于小项目来说可有可无，但是实践证明它在大项目中非常有用。

 使用模式库是从传统的CSS开发方式转变而来的一种解决方案。不同于之前的先写HTML页面再写样式，我们实现了模块化的样式，然后使用这些模块拼装成Web页面。我把这种解决方案称为CSS优先（CSS First）开发方式，先写CSS，而不是HTML。你可以（并且应该）按照模式库的方式开发CSS，然后在项目中使用这些CSS

2023/10/09发表想法
互联网分工明确的又一体现，相比作者就是这部分成员哈哈
 第三，这种开发方式允许团队里一部分成员专注于开发CSS。对CSS不太熟悉的开发者可以把一部分工作移交给经验更丰富的人。擅长CSS的开发者每完成一个模块，就可以向其他人发送一个链接，指向模式库里的模块位置。

 第三，这种开发方式允许团队里一部分成员专注于开发CSS。对CSS不太熟悉的开发者可以把一部分工作移交给经验更丰富的人。擅长CSS的开发者每完成一个模块，就可以向其他人发送一个链接，指向模式库里的模块位置。

2023/10/09发表想法
突然觉得，我们平时调用swiper.js之类的库，不也是使用了模式库的思维

 API——应用程序接口，是指一组预先定义好的子程序，可以用来调用系统功能或与系统交互。API一般包含方法名和参数（在编程语言中），或者包含URL和查询参数（在HTTP API中）。我在描述模块化CSS的时候也使用了API的说法，是为了阐明HTML代码是通过类名和HTML元素连接CSS样式的。

 API——应用程序接口，是指一组预先定义好的子程序，可以用来调用系统功能或与系统交互。API一般包含方法名和参数（在编程语言中），或者包含URL和查询参数（在HTTP API中）。我在描述模块化CSS的时候也使用了API的说法，是为了阐明HTML代码是通过类名和HTML元素连接CSS样式的。

 创建模块的时候，API的结构是最重要的部分，因为后面很难再修改。当然，HTML有可以随意修改的地方：每个元素里的内容可以任意改变。有些情况下，模块里的DOM元素可以增加、移除甚至改变排序（如果元素是可选的或者可以改变顺序，一定要在文档中明确说明）。

 只要API的核心部件（类名和DOM结构）没有改变，就可以把CSS任意修改成自己想要的效果。

 做出的这些修改会影响到网站的很多地方跟着变化，但是只要HTML按照API的结构书写，这些变化就会符合预期。

 模式库现在扮演了一个类似于球场围栏的角色，它可以告诉你对CSS的修改是否破坏了网站上已有的媒体对象，同时检验新代码是否有效。现在可以重构CSS来实现新的媒体场景。修改样式表除了让第二个实例正常工作，还要确保修改过程中不破坏第一个实例。

 如果没有模块化CSS和模式库，修改CSS就可能会造成网站样式混乱，我们没办法查明为什么HTML到处都是，也不确定选择器是否还能找到正确的元素。有了这些稳定不变的API，配合模式库文档，再修改CSS就会变得轻松愉悦。

 我们如果只做一些小修改（比如修改bug），就增加修订版本号（例如，从1.4.2到1.4.3）；如果添加了新的模块或功能，但是没有修改API，或者某个模块被标为废弃，就增加次版本号，把修订版本号设置为0（例如，从1.4.2到1.5.0）；如果过滤了一遍样式表文件把废弃模块都删除了，就需要直接跳到下一个主版本号（例如，从1.4.2到2.0.0）。有时候我们做了大量的外观设计修改（比如网站重新设计了），这时候也需要升级主版本号，即使API还保持原样。

 有了版本控制，就可以按照需求配置项目使用任意版本的CSS了。

 这也正是为什么这些框架都是成功的，因为它们每一个都是模式库

 这些框架和个人的模式库之间的不同是，框架更通用。在模式库里，模块是为项目定制化的，可以更好地契合项目使用，带有项目本身特有的观感。比如你可以根据需要创建两个不同类型的板块模块，再有其他需要还可以很快改写更多。

 总有开发者问我，到底需不需要使用Bootstrap这样的框架。我会回答，既需要也不需要。框架有助于项目快速起步。你不需要做多少工作，就可以获取现成的按钮、板块和下拉菜单。但是根据我的经验，框架从来都不能提供你所需的全部模块。除非是很小的项目，否则你总要再写一些自己的模块。当然了，框架也会提供很多你根本用不到的模块。

 如果你确实想使用自己熟悉的框架，我建议只取其中你需要的那一部分，用不到的部分丢掉。不要只在页面上粘贴一个bootstrap.css文件，而是把你需要的那些模块复制到你自己的样式表里（如果框架的许可协议允许这样做的话），然后把这部分CSS改造成你自己的样式。

 如果你在页面里添加一个CSS框架，放在自己的样式表前面，接下来你就需要写一大堆样式来覆盖和补充框架样式。如果换一种实现方式，把框架里的样式放到自己的样式表里，就可以直接修改样式了。

 不要盲目地使用框架，要学习思考框架背后的设计思路。

 以模块化的方式来组织CSS代码，再维护一套与之相应的模式库，就可以避免陷入这样尴尬的境地。你总是知道某个模块的样式位于何处。每个模块只用来做一件事。同时，模式库还有助于开发者密切监视样式表开发过程中的进展情况。

## 10.3 总结

 ❑ 使用工具来存档和清点模块，比如KSS。❑ 使用模式库来记录HTML标记示例、模块变体和模块的JavaScript。❑ 开发模块时遵循“CSS优先”。❑ 考虑好CSS定义的API，之后不要轻易修改它。❑ 使用语义版本为CSS做版本控制。❑ 不要盲目地添加整个CSS框架到页面上，只取自己需要的那部分。
